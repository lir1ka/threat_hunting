---
title: "pr 05 vakhrameev"
author: "vakhrameevaleksandr@yandex.ru"
format: 
  md:
    output-file: README.md
---

## Цель работы

1. Получить знания о методах исследования радиоэлектронной обстановки.
2. Составить представление о механизмах работы Wi-Fi сетей на канальном и сетевом уровне модели OSI.
3. Зекрепить практические навыки использования языка программирования R для обработки данных
4. Закрепить знания основных функций обработки данных экосистемы tidyverse языка R

## Исходные данные

1.  Оепрационная система Darwin Mac.lan 25.0.0 Darwin Kernel Version 25.0.0
2.  IDE Positron
3.  R version 4.5.2
4.  Логи инструментов для анализа беспроводных сетей — `tcpdump` и `airodump-ng`.

## Задание

Используя программный пакет `dplyr` языка программирования R провести анализ журналов и ответить на вопросы

### Ход работы

### Подготовка данных

1. Импортируйте данные
2. Привести датасеты в вид “аккуратных данных”, преобразовать типы столбцов в
соответствии с типом данных
3. Просмотрите общую структуру данных с помощью функции `glimpse()`

### Анализ данных

1. Определить небезопасные точки доступа (без шифрования – OPN)
2. Определить производителя для каждого обнаруженного устройства
3. Выявить устройства, использующие последнюю версию протокола шифрования WPA3, и названия точек доступа, реализованных на этих устройствах
4. Отсортировать точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию.
5. Обнаружить топ-10 самых быстрых точек доступа.
6. Отсортировать точки доступа по частоте отправки запросов (beacons) в единицу времени по их убыванию.
7. Определить производителя для каждого обнаруженного устройства.
8. Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес.
9. Кластеризовать запросы от устройств к точкам доступа по их именам. Определить время появления устройства в зоне радиовидимости и время
выхода его из нее.
10. Оценить стабильность уровня сигнала внури кластера во времени. Выявить наиболее стабильный кластер.



### Шаг 1. Подготовка данных

Инициализируем рабочую среду, загрузив необходимые библиотеки для обработки данных:

```{r}
suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(tidyr)
  library(knitr)
  library(readr)
})
```

Загружаем исходный датасет из облачного хранилища:

```{r}
DATA_URL <- "https://storage.yandexcloud.net/dataset.ctfsec/P2_wifi_data.csv"
TEMP_DIR <- tempdir()
DATA_FILE <- file.path(TEMP_DIR, "P2_wifi_data.csv")

if (!file.exists(DATA_FILE)) {
  download.file(url = DATA_URL, destfile = DATA_FILE, mode = "wb")
}
```

Выполняем чтение данных с разделением на два датасета: точки доступа и клиентские устройства:

```{r}
suppressWarnings({
  file_content <- read_lines(DATA_FILE)
  section_boundary <- which(grepl("^Station MAC", file_content, ignore.case = TRUE))
  
  if (length(section_boundary) > 0) {
    wifi_ap_raw <- read_csv(DATA_FILE, n_max = section_boundary[1] - 2, show_col_types = FALSE)
    clients_raw <- read_csv(DATA_FILE, skip = section_boundary[1] - 1, show_col_types = FALSE)
  } else {
    stop("Не удалось определить границу между секциями данных")
  }
})

print("Структура клиентских данных:")
head(clients_raw, 2)
```

Выполняем нормализацию и типизацию данных для датасета точек доступа:

```{r}
normalize_access_points <- function(df) {
  names(df) <- trimws(names(df))
  
  df %>%
    rename(
      bssid      = BSSID,
      first_seen = `First time seen`,
      last_seen  = `Last time seen`,
      channel    = channel,
      speed      = Speed,
      privacy    = Privacy,
      cipher     = Cipher,
      auth       = Authentication,
      power      = Power,
      beacons    = `# beacons`,
      iv_count   = `# IV`,
      lan_ip     = `LAN IP`,
      id_length  = `ID-length`,
      essid      = ESSID,
      key        = Key
    ) %>%
    mutate(across(where(is.character), ~ trimws(.))) %>%
    mutate(
      first_seen = as.POSIXct(first_seen, format = "%Y-%m-%d %H:%M:%S", tz = "UTC"),
      last_seen  = as.POSIXct(last_seen,  format = "%Y-%m-%d %H:%M:%S", tz = "UTC"),
      channel    = as.numeric(channel),
      speed      = as.numeric(speed),
      power      = as.numeric(power),
      beacons    = as.numeric(beacons),
      iv_count   = as.numeric(iv_count),
      id_length  = as.numeric(id_length)
    )
}

wifi_ap_clean <- normalize_access_points(wifi_ap_raw)
```

Применяем аналогичную процедуру нормализации для датасета клиентских устройств:

```{r}
normalize_clients <- function(df) {
  names(df) <- trimws(names(df))
  
  df %>%
    rename(
      station_mac   = `Station MAC`,
      first_seen    = `First time seen`,
      last_seen     = `Last time seen`,
      power         = Power,
      packets       = `# packets`,
      bssid         = BSSID,
      probed_essids = `Probed ESSIDs`
    ) %>%
    mutate(across(where(is.character), ~ trimws(.))) %>%
    mutate(
      first_seen  = as.POSIXct(first_seen, format = "%Y-%m-%d %H:%M:%S", tz = "UTC"),
      last_seen   = as.POSIXct(last_seen,  format = "%Y-%m-%d %H:%M:%S", tz = "UTC"),
      power       = as.numeric(power),
      packets     = as.numeric(packets),
      station_mac = toupper(station_mac),
      bssid = case_when(
        is.na(bssid) ~ NA_character_,
        grepl("not associated", bssid, ignore.case = TRUE) ~ NA_character_,
        TRUE ~ toupper(bssid)
      )
    )
}

wifi_clients_clean <- normalize_clients(clients_raw)
```

Проводим инспекцию структуры нормализованных датасетов:

```{r}
cat("Структура датасета точек доступа:\n")
glimpse(wifi_ap_clean)

cat("\nСтруктура датасета клиентских устройств:\n")
glimpse(wifi_clients_clean)
```

### Шаг 2. Анализ данных

#### 1. Определить небезопасные точки доступа (без шифрования – OPN)

Выполняем фильтрацию точек доступа с отсутствующим шифрованием:

```{r}
insecure_access_points <- wifi_ap_clean %>%
  filter(privacy == "OPN") %>%
  select(bssid, essid, privacy, channel, power)

insecure_access_points
```

#### 2. Определить производителя для каждого обнаруженного устройства

Инициализируем справочник производителей на основе OUI-таблицы Wireshark:

```{r}
MANUF_URL  <- "https://raw.githubusercontent.com/observ3r/wobs/master/manuf.txt"
MANUF_FILE <- file.path(TEMP_DIR, "manuf.txt")

if (!file.exists(MANUF_FILE)) {
  download.file(MANUF_URL, MANUF_FILE, mode = "wb", quiet = TRUE)
}

manuf_raw <- read.table(
  MANUF_FILE,
  comment.char      = "#",
  stringsAsFactors  = FALSE,
  fill              = TRUE
)

manuf_tbl <- manuf_raw %>%
  transmute(
    prefix6 = toupper(gsub(":", "", V1)), 
    vendor  = V2
  ) %>%
  filter(nchar(prefix6) == 6, vendor != "") %>%
  distinct()
```

Реализуем функцию для нормализации MAC-адресов:

```{r}
normalize_mac <- function(mac_address) {
  toupper(gsub("[^0-9A-F]", "", mac_address))
}
```

Обогащаем датасет точек доступа информацией о производителях:

```{r}
wifi_ap_clean <- wifi_ap_clean %>%
  mutate(prefix6 = substr(normalize_mac(bssid), 1, 6)) %>%
  left_join(manuf_tbl, by = "prefix6")
```

Выполняем просмотр результатов идентификации производителей:

```{r}
wifi_ap_clean %>%
  select(bssid, essid, vendor) %>%
  filter(!is.na(vendor)) %>%
  head(20)
```

#### 3. Выявить устройства, использующие последнюю версию протокола шифрования WPA3, и названия точек доступа, реализованных на этих устройствах

Идентифицируем точки доступа с поддержкой протокола WPA3:

```{r}
wpa3_access_points <- wifi_ap_clean %>%
  filter(
    grepl("WPA3", privacy, ignore.case = TRUE) | 
    grepl("SAE", auth, ignore.case = TRUE)
  ) %>%
  select(bssid, essid, privacy, auth, vendor)

wpa3_access_points
```

#### 4. Отсортировать точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию

Выполняем агрегацию записей в сессии и вычисление длительности активности. Сессии разделяются при интервале между записями более 45 минут:

```{r}
aggregate_access_point_sessions <- function(df, session_gap_minutes = 45) {
  df %>%
    arrange(bssid, first_seen) %>%
    group_by(bssid) %>%
    mutate(
      gap_minutes = as.numeric(difftime(first_seen, lag(last_seen), units = "mins")),
      is_new_session = if_else(is.na(gap_minutes) | gap_minutes > session_gap_minutes, 1L, 0L),
      session_id = cumsum(is_new_session)
    ) %>%
    group_by(bssid, session_id) %>%
    summarise(
      essid      = first(essid),
      vendor     = first(vendor),
      first_seen = min(first_seen, na.rm = TRUE),
      last_seen  = max(last_seen,  na.rm = TRUE),
      beacons    = sum(beacons,    na.rm = TRUE),
      speed      = max(speed,      na.rm = TRUE),
      mean_power = mean(power,     na.rm = TRUE),
      .groups    = "drop"
    ) %>%
    mutate(
      duration_seconds = as.numeric(difftime(last_seen, first_seen, units = "secs")),
      beacon_rate = beacons / duration_seconds
    )
}

wifi_ap_sessions <- aggregate_access_point_sessions(wifi_ap_clean)
```

Выполняем сортировку по длительности сессий:

```{r}
access_points_by_duration <- wifi_ap_sessions %>%
  arrange(desc(duration_seconds)) %>%
  select(bssid, essid, vendor, session_id, duration_seconds, first_seen, last_seen)

access_points_by_duration
```

#### 5. Обнаружить топ-10 самых быстрых точек доступа

Идентифицируем точки доступа с максимальной пропускной способностью:

```{r}
top_speed_access_points <- wifi_ap_sessions %>%
  arrange(desc(speed)) %>%
  slice_head(n = 10) %>%
  select(bssid, essid, vendor, session_id, speed, first_seen, last_seen)

top_speed_access_points
```

#### 6. Отсортировать точки доступа по частоте отправки запросов (beacons) в единицу времени по их убыванию

Выполняем ранжирование точек доступа по интенсивности отправки beacon-кадров:

```{r}
access_points_by_beacon_rate <- wifi_ap_sessions %>%
  filter(is.finite(beacon_rate)) %>%
  arrange(desc(beacon_rate)) %>%
  select(bssid, essid, vendor, session_id, beacons, duration_seconds, beacon_rate)

access_points_by_beacon_rate
```

#### 7. Определить производителя для каждого обнаруженного устройства

Применяем аналогичную процедуру идентификации производителей для клиентских устройств:

```{r}
wifi_clients_clean <- wifi_clients_clean %>%
  mutate(prefix6 = substr(normalize_mac(station_mac), 1, 6)) %>%
  left_join(manuf_tbl, by = "prefix6")
```

Выполняем просмотр результатов идентификации производителей клиентских устройств:

```{r}
wifi_clients_clean %>%
  select(station_mac, vendor, bssid, power, packets) %>%
  filter(!is.na(vendor)) %>%
  head(20)
```

#### 8. Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес

Реализуем алгоритм определения рандомизации MAC-адресов на основе анализа битов первого октета:

```{r}
is_randomized_mac <- function(mac_address) {
  mac_hex <- normalize_mac(mac_address)
  
  if (nchar(mac_hex) < 2) return(NA)
  
  first_octet <- strtoi(substr(mac_hex, 1, 2), base = 16)
  if (is.na(first_octet)) return(NA)
  
  if (bitwAnd(first_octet, 0x01) != 0) return(NA)
  
  bitwAnd(first_octet, 0x02) != 0
}
```

Выполняем идентификацию устройств с нерандомизированными MAC-адресами:

```{r}
non_randomized_clients <- wifi_clients_clean %>%
  mutate(is_randomized = vapply(station_mac, is_randomized_mac, logical(1))) %>%
  filter(is_randomized == FALSE) %>%
  select(station_mac, vendor, bssid, first_seen, last_seen, power, packets)

non_randomized_clients
```

#### 9. Кластеризовать запросы от устройств к точкам доступа по их именам. Определить время появления устройства в зоне радиовидимости и время выхода его из нее

Выполняем нормализацию идентификаторов сетей (ESSID) для последующей кластеризации:

```{r}
access_point_essid_map <- wifi_ap_clean %>%
  mutate(essid_normalized = str_squish(essid)) %>%
  select(bssid, essid_normalized) %>%
  distinct()
```

Выполняем кластеризацию взаимодействий устройств с точками доступа:

```{r}
device_network_clusters <- wifi_clients_clean %>%
  filter(!is.na(bssid)) %>%
  left_join(access_point_essid_map, by = "bssid") %>%
  filter(!is.na(essid_normalized), essid_normalized != "") %>%
  group_by(station_mac, essid_normalized) %>% 
  summarise(
    first_seen      = min(first_seen, na.rm = TRUE),
    last_seen       = max(last_seen,  na.rm = TRUE),
    duration_seconds = as.numeric(difftime(last_seen, first_seen, units = "secs")),
    record_count    = n(),
    .groups         = "drop"
  ) %>%
  arrange(desc(duration_seconds), station_mac, essid_normalized)

device_network_clusters
```

#### 10. Оценить стабильность уровня сигнала внутри кластера во времени. Выявить наиболее стабильный кластер

Выполняем анализ стабильности уровня сигнала для кластеров (устройство, сеть):

```{r}
signal_stability_clusters <- wifi_clients_clean %>%
  filter(!is.na(bssid)) %>%
  left_join(access_point_essid_map, by = "bssid") %>%
  filter(!is.na(essid_normalized), essid_normalized != "") %>%
  group_by(station_mac, essid_normalized)
```

Вычисляем метрики стабильности сигнала и идентифицируем наиболее стабильный кластер:

```{r}
signal_stability_metrics <- signal_stability_clusters %>%
  summarise(
    observation_count = n(),
    time_span_minutes = as.numeric(difftime(max(last_seen), min(first_seen), units = "mins")),
    rssi_std_dev      = sd(power, na.rm = TRUE),
    rssi_mean         = mean(power, na.rm = TRUE),
    .groups           = "drop"
  ) %>%
  arrange(rssi_std_dev)

most_stable_cluster <- slice_head(signal_stability_metrics, n = 1)

cat("Метрики стабильности сигнала:\n")
print(signal_stability_metrics)

cat("\nНаиболее стабильный кластер:\n")
print(most_stable_cluster)
```

### Шаг 3.

Отчет подготовлен и оформлен.


## Вывод

В ходе практической работы я улучшил навыки использования языка программирования R, а также освоил анализ данных о состоянии беспроводных сетей.